use std::collections::{BTreeSet, HashMap, HashSet};

use petgraph::{
    algo::is_isomorphic,
    graph::{EdgeIndex, Graph, NodeIndex},
    Undirected,
};

use crate::utils::{edge_induced_subgraph, is_subset_connected};

type Index = u32;
type MGraph = Graph<Atom, Bond, Undirected, Index>;

#[derive(Debug, Clone)]
pub enum Element {
    Hydrogen,
    Carbon,
    Nitrogen,
    Oxygen,
}

#[derive(Debug, Clone)]
pub struct Atom {
    element: Element,
    capacity: u32,
}

#[derive(Debug, Clone)]
pub enum Bond {
    Single,
    Double,
}

#[derive(Debug, Clone)]
pub struct Molecule {
    graph: MGraph,
}

impl Atom {
    pub fn new(element: Element) -> Self {
        Self {
            element,
            capacity: 0,
        }
    }
}

impl Molecule {
    /// Join self with other on `on`
    pub fn join(
        &self,
        other: &Molecule,
        on: impl IntoIterator<Item = (NodeIndex, NodeIndex)>,
    ) -> Option<Molecule> {
        let mut output_graph = self.clone();

        let mut v_set = HashSet::<NodeIndex>::new();
        let mut io_map = HashMap::<NodeIndex, NodeIndex>::new();

        for (u, v) in on.into_iter() {
            v_set.insert(v);
            io_map.insert(v, u);
        }

        for ix in other.graph.node_indices() {
            if !v_set.contains(&ix) {
                let w = other.graph.node_weight(ix).unwrap().clone();
                let out = output_graph.graph.add_node(w);
                io_map.insert(ix, out);
            }
        }

        for ix in other.graph.edge_indices() {
            let (u, v) = other.graph.edge_endpoints(ix).unwrap();
            let um = io_map.get(&u).unwrap();
            let vm = io_map.get(&v).unwrap();
            let w = other.graph.edge_weight(ix).unwrap().clone();

            output_graph.graph.add_edge(*um, *vm, w);
        }

        Some(output_graph)
    }

    pub fn is_isomorphic_to(&self, other: &Molecule) -> bool {
        is_isomorphic(&self.graph, &other.graph)
    }

    /// Split molecule on `on` and return an iterator over all possible molecule pairs generated by
    /// this split
    // pub fn split(
    //     &self,
    //     on: impl IntoIterator<Item = NodeIndex>,
    // ) -> Option<impl Iterator<Item = (Molecule, Molecule)>> {
    // }

    /// Iterator over every joinable set of n vertices in self
    // pub fn n_join_points(&self, n: usize) -> impl Iterator<Item = impl Iterator<Item = Index>> {}

    pub fn partitions(&self) -> Option<impl Iterator<Item = (Molecule, Molecule)> + '_> {
        let mut solutions = HashSet::new();
        let remaining_edges = self.graph.edge_indices().collect();
        self.backtrack(
            remaining_edges,
            BTreeSet::new(),
            BTreeSet::new(),
            &mut solutions,
        );
        Some(solutions.into_iter().map(|(left, right)| {
            (
                Molecule {
                    graph: edge_induced_subgraph(self.graph.clone(), &left),
                },
                Molecule {
                    graph: edge_induced_subgraph(self.graph.clone(), &right),
                },
            )
        }))
    }

    fn backtrack(
        &self,
        remaining_edges: Vec<EdgeIndex>,
        left: BTreeSet<EdgeIndex>,
        right: BTreeSet<EdgeIndex>,
        solutions: &mut HashSet<(BTreeSet<EdgeIndex>, BTreeSet<EdgeIndex>)>,
    ) {
        if remaining_edges.is_empty() {
            if self.is_valid_partition(&left, &right) {
                solutions.insert((left, right));
            }
            return;
        }

        let mut prefix = remaining_edges.clone();
        let suffix = prefix.pop().unwrap();
        let mut new_left = left.clone();
        new_left.insert(suffix);

        let mut new_right = left.clone();
        new_right.insert(suffix);

        self.backtrack(prefix.clone(), new_left, right, solutions);
        self.backtrack(prefix, left, new_right, solutions);
    }

    fn is_valid_partition(&self, left: &BTreeSet<EdgeIndex>, right: &BTreeSet<EdgeIndex>) -> bool {
        !left.is_empty()
            && !right.is_empty()
            && is_subset_connected(&self.graph, left)
            && is_subset_connected(&self.graph, right)
    }

    pub fn from_graph(g: MGraph) -> Self {
        Self { graph: g }
    }

    pub fn single_bond() -> Self {
        let mut g = Graph::default();
        let u = g.add_node(Atom {
            capacity: 4,
            element: Element::Carbon,
        });
        let v = g.add_node(Atom {
            capacity: 4,
            element: Element::Carbon,
        });
        g.add_edge(u, v, Bond::Single);
        Self { graph: g }
    }

    pub fn double_bond() -> Self {
        let mut g = Graph::default();
        let u = g.add_node(Atom {
            capacity: 4,
            element: Element::Carbon,
        });
        let v = g.add_node(Atom {
            capacity: 4,
            element: Element::Carbon,
        });
        g.add_edge(u, v, Bond::Double);
        Self { graph: g }
    }

    pub fn carbonyl() -> Self {
        let mut g = Graph::default();
        let u = g.add_node(Atom {
            capacity: 4,
            element: Element::Carbon,
        });
        let v = g.add_node(Atom {
            capacity: 2,
            element: Element::Oxygen,
        });
        g.add_edge(u, v, Bond::Double);
        Self { graph: g }
    }

    pub fn hydroxyl() -> Self {
        let mut g = Graph::default();
        let u = g.add_node(Atom {
            capacity: 4,
            element: Element::Carbon,
        });
        let v = g.add_node(Atom {
            capacity: 2,
            element: Element::Oxygen,
        });
        g.add_edge(u, v, Bond::Single);
        Self { graph: g }
    }
}

mod tests {
    use super::*;

    #[test]
    fn join_carbonyl_hydroxyl() {
        let c = Molecule::carbonyl();
        let h = Molecule::hydroxyl();
        let j = c
            .join(&h, [(NodeIndex::new(0), NodeIndex::new(0))])
            .unwrap();

        let mut g = Graph::default();
        let u = g.add_node(Atom {
            capacity: 4,
            element: Element::Carbon,
        });
        let v = g.add_node(Atom {
            capacity: 2,
            element: Element::Oxygen,
        });
        let w = g.add_node(Atom {
            capacity: 2,
            element: Element::Oxygen,
        });
        g.add_edge(u, v, Bond::Single);
        g.add_edge(u, w, Bond::Double);

        assert!(j.is_isomorphic_to(&Molecule { graph: g }));
    }
}
